\section{Related Work} \label{sec:related}

Existing analysis frameworks can be classsified into two approaches depending 
on how a framework exposes an application's actual execution states to an 
anlysis tool. The first approach fully or mostly inlines an analysis within an 
actual execution, which may cause prohibitive slowdown in the executions when 
an analysis does heavyweight work. Recently, researchers have proposed to 
decouple analysis from execution via parallely executing analysis and 
record-replay. We classify these frameworks into ``partially-decoupled" 
approach because they still need to frequently transfer execution states from 
the execution (\eg, effective memory addresses and thread interleavings) to 
analysis. These ``partially-decoupled" frameworks have shown up to 4X speedup 
over the traditional frameworks on the same analysis, which shows that 
decoupling analysis from execution is a promissing direction. \xxx fully 
decouples analysis from execution via replicating equavalent executions.

\smr has been studied by the literature for decades, and it is recognized by 
both industry and academia as a powerful fault-tolerance technique in clouds 
and distributed systems~\cite{lamportclock, smr:tutorial}. As a common 
standard, SMR uses \paxos~\cite{paxos} as the consensus protocol to ensure that 
all nodes see the same input request sequence. In this standard, nodes first 
``agree" on a total order of input request as a input sequence, and then 
``execute" the requests that have reached this consensus. This typical SMR 
approach is called ``agree-execute". SMR systems, including 
Chubby~\cite{chubby:osdi}, ZooKeeper~\cite{zookeeper}, and 
the Microsoft \paxos~\cite{paxos} implementation, have been widely used to 
maintain critical distributed systems configurations (\eg, group leaders, 
distributed locks, and storage meta data). SMR has also been applied broadly to 
build various highly available services, including 
storage~\cite{paxos:datastore} and wide-area network~\cite{mencius:osdi08}. 
Hypervisor-based Fault Tolerance~\cite{hft:sosp95} leverages a hypervisor to 
build a primary-back system for single-core machines. Unlike \xxx that 
transparently replicate applications via introducing the socket API-based 
consensue interface, hese systems focus on only specific types of applications 
(\eg, distributed lock service~\cite{chubby:osdi}, file 
system~\cite{zookeeper}).

