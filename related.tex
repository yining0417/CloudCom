\section{Related Work} \label{sec:related}

Existing analysis frameworks can be classified into two approaches depending 
on how a framework exposes an application's actual execution states to an 
analysis tool. The first approach in-lines an analysis within an 
actual execution~\cite{dynamorio, pin:pldi05, 
valgrind:pldi, lift:micro06, tsan}, which may cause prohibitive slowdown in the
executions when an analysis does heavyweight work. Recently, researchers have
proposed to 
decouple analysis from execution~\cite{decouple:usenix08, speck:asplos08, 
shadowreplica:ccs13, wester:parallelizing:asplos13, superpin, jungwoo:oopsla09} 
via parallely executing analysis, record-replay, and so on. We classify these
frameworks into ``partially-decoupled" approach because they still need to
frequently 
transfer execution states from the execution (\eg, effective memory addresses 
and thread interleavings) to analysis. These ``partially-decoupled" frameworks 
have shown 4X$\sim$8X speedup over the traditional frameworks on the same 
analysis, which shows that decoupling analysis from execution is a promising 
direction. \xxx fully decouples analysis from execution via replicating 
equivalent executions.

\smr has been studied by the literature for decades, and it is recognized by 
both industry and academia as a powerful fault-tolerance technique in clouds 
and distributed systems~\cite{lamportclock, smr:tutorial}. As a common 
standard, SMR uses \paxos~\cite{paxos} as the consensus protocol to ensure that 
all nodes see the same input request sequence. In this standard, nodes first 
``agree" on a total order of input request as a input sequence, and then 
``execute" the requests that have reached this consensus. This typical SMR 
approach is called ``agree-execute". SMR systems, including 
Chubby~\cite{chubby:osdi}, ZooKeeper~\cite{zookeeper}, and 
the Microsoft \paxos~\cite{paxos} implementation, have been widely used to 
maintain critical distributed systems configurations (\eg, group leaders, 
distributed locks, and storage meta data). SMR has also been applied broadly to 
build various highly available services, including 
storage~\cite{paxos:datastore} and wide-area network~\cite{mencius:osdi08}. 
Hypervisor-based Fault Tolerance~\cite{hft:sosp95} leverages a hypervisor to 
build a primary-back system for single-core machines. These systems focus on 
specific types of applications (\eg, distributed lock service~\cite{chubby:osdi}, file 
system~\cite{zookeeper}) and thus they are not designed to be transparent to 
general server applications.

\repbox~\cite{repbox:sosp15} is the first \smr system to transparently 
replicate server applications for fault-tolerance. \xxx is a program analysis 
framework which leverages \repbox's \paxos implementation to transparently support analysis 
tools. To the best of our knowledge, \xxx is the first work that applies the 
\smr concept to a new domain: constructing multiple equivalent executions for transparent 
analyses. \xxx is not designed for fault-tolerance.

